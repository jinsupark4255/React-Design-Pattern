- 리액트는 구성에 초점을 맞추고 있기 때문에, 디자인 시스템의 요소들과 완벽하게 연결될 수 있다.
- 따라서 리액트를 효과적으로 활용하려면 모듈화된 사고방식이 필요하다.
- 리액트는 페이지나 뷰를 구성하기 전에 개별 컴포넌트를 먼저 개발하도록 하기에, 각 컴포넌트의 역할과 목적을 확실히 할 수 있다.

## 리액트 용어 소개
### ReactDOM
- 클라이언트와 서버 렌더링에서 DOM에 특화된 메서드를 제공하는 react-dom 패키지.
### JSX
- HTML과 유사한 구조로 UI 요소를 정의할 수 있게 해주는 자바스크립트의 문법 확장.
### Hooks
- 클래스 컴포넌트가 아니더라도 state와 기타 리액트의 기능들을 사용할 수 있게 해주는 새로운 기능.
### 리액트 네이티브
- 자바스크립트로 iOS, Android 등의 다양한 플랫폼에서 동작하는 네이티브 애플리케이션을 개발할 수 있게 해주는 크로스 플랫폼 라이브러리.
### 서버 사이드 렌더링
- SSR은 사용자 요청에 응답하여 페이지 콘텐츠를 데이터 저장소나 외부 API의 데이터가 포함된 완전한 HTML 파일로 생성한다.
- 리액트는 동형 렌더링이 가능해 브라우저뿐만 아니라 서버 같은 다른 플랫폼에서도 작동할 수 있음을 의미한다.
- 따라서 리액트를 사용하여 서버에서 UI 요소를 렌더링할 수 있다.
### 하이드레이션
- 서버에서 렌더링된 애플리케이션에서는 현재 페이지의 HTML이 서버에서 생성되어 클라이언트로 전송된다.
- 서버에서 이미 마크업을 생성했기 때문에 클라이언트는 이를 빠르게 파싱하여 화면에 나타낼 수 있다.
- 그런 다음, UI를 상호작용할 수 있게 만드는 데 필요한 자바스크립트가 로드된다.
- 버튼과 같은 UI 요소를 상호작용할 수 있게 하는 이벤트 핸들러는 자바스크립트 번들이 로드되고 처리된 후에야 비로소 연결된다.
- 이러한 일련의 과정을 하이드레이션이라고 한다.

# 고차 컴포넌트
- 고차 컴포넌트 패턴은 여러 컴포넌트에서 동일한 로직을 재사용하는 방법 중 하나다.
- 이 패턴을 사용하면 애플리케이션 전체에서 컴포넌트 로직을 재사용할 수 있다.
- 고차 컴포넌트는 다른 컴포넌트를 인자로 받아 새로운 컴포넌트를 반환하는 컴포넌트이다.
- 고차 컴포넌트는 특정 기능을 포함하고 있어, 이 기능을 매개변수로 전달받은 컴포넌트에 적용할 수 있다.
- 그리하여 고차 컴포넌트는 인자로 받은 컴포넌트에 추가 기능을 적용한 새로운 컴포넌트를 반환한다.
- 애플리케이션 내 여러 컴포넌트에 특정 스타일을 적용하고 싶다고 가정해 보자.
- 매번 스타일 객체를 일일이 생성하는 대신, 매개변수로 전달받은 컴포넌트에 스타일 객체를 추가하는 고차 컴포넌트를 만들 수도 있다.
```tsx
function withStyles(Component) {
    return props => {
        const style = { padding: '0.2rem', margin: '1rem' }
        return <Component style={style} {...props} />
    }
}

const Button = () => <button>Click me!</button>
const Text = () => <p>Hello World!</p>

const StyledButton = withStyles(Button)
const StyledText = withStyles(Text)
```
- 더 나아가, API에서 가져온 데이터로 강아지 이미지 목록을 렌더링하는 애플리케이션을 살펴보자.
- 데이터를 가져오는 동안 사용자에게 로딩 화면을 보여주고 싶다면 이 기능을 DogImages 컴포넌트에 직접 추가하는 대신에 로딩 화면을 추가하는 고차 컴포넌트를 활용할 수 있다.
- Dog API URL을 하드코딩하기 보다는, withLoader 고차 컴포넌트의 재사용성을 높이기 위해서 URL을 withLoader 고차 컴포넌트에 인자로 전달한다.
- 이렇게 하면 다른 API 엔드포인트에서도 데이터를 가져오는 동안 로딩 중 표시가 필요한 컴포넌트에서 이 로더를 재사용할 수 있다.
```tsx
import React, { useEffect, useState } from "react";

export default function withLoader(Element, url) {
    return (props) => {
        const [data, setData] = useState(null);

        useEffect(() => {
            async function getData() {
                const res = await fetch(url);
                const data = await res.json();
                setData(data);
            }

            getData();
        }, []);

        if (!data) {
            return <div>Loading...</div>
        }

        return <Element {...props} data={data} />;
    };
}
```
- withLoader가 데이터 상태를 대상 컴포넌트에 넘겨주기 때문에, DogImages 컴포넌트 내에서 이 데이터 상태를 prop으로서 접근할 수 있다.
```tsx
import React from "react";
import withLoader from "./withLoader";

function DogImages(props) {
    return props.data.messsage.map((dog, index) => {
        <img src={dog} alt="Dog" key={index} />
    });
}

export default withLoader(
    DogImages,
    "https://dog-example/1"
)
```
- 고차 컴포넌트 패턴을 사용하면 필요한 로직을 한 곳에 유지하면서 동시에 여러 컴포넌트에 동일한 로직을 제공할 수 있다.
- withLoader 고차 컴포넌트는 어떤 컴포넌트나 URL을 받을지 신경 쓰지 않는다.

# 고차 컴포넌트 조합하기
- 때로는 여러 고차 컴포넌트를 조합하여 사용할 수도 있다.
- DogImages 목록 위로 마우스 커서를 가져가면 텍스트 박스를 표시하는 기능을 추가한다고 가정해보자.
```ts
export default withHover(
    withLoader(DogImages, "https://dog-example/2")
);
```
- 고차 컴포넌트 패턴을 사용하면 단점으로 깊게 중첩된 컴포넌트 트리가 만들어지기 쉽다.
- 고차 컴포넌트 패턴은 다음과 같은 경우에 효과적이다.
```md
- 애플리케이션 전체에 걸쳐 여러 컴포넌트에 동일한 동작을 적용해야 할 때
- 추가된 커스텀 로직 없이도 컴포넌트가 독립적으로 작동할 수 있을 때
```

### 장점
- 고차 컴포넌트 패턴을 사용하면 재사용하고자 하는 로직을 한 곳에 모아 관리할 수 있다.
- 이렇게 하면 코드를 여기저기 복사하면서 실수로 버그를 퍼뜨릴 위험을 줄일 수 있다.
- 로직을 한 곳에 집중시킴으로써 코드를 DRY하게 유지하고, 효과적으로 관심사를 분리할 수 있다.

### 단점
- 고차 컴포넌트가 대상 컴포넌트에 전달하는 prop의 이름은 충돌을 일으킬 수 있다.
```tsx
function withStyles(Component) {
    return props => {
        const style = { padding: '0.2rem', margin: '1rem' }
        return <Component style={style} {...props} />
    }
}

const Button = () => <button style={{color: 'red'}}>Click me!</button>
const StyledButton = withStyles(Button)
```
- 이 경우, withStyles 고차 컴포넌트는 전달받은 컴포넌트에 style이라는 이름의 prop을 추가한다.
- 하지만 Button 컴포넌트는 이미 style prop을 가지고 있어, 자칫하면 덮어씌워질 수 있다.
- 이러한 이름 충돌을 피하려면 prop의 이름을 변경하거나 병합하는 방식이 필요하다.
```tsx
function withStyles(Component) {
    return props => {
        const style = {
            padding: '0.2rem',
            margin: '1rem',
            ...props.style
        }

        return <Component style={style} {...props} />
    }
}

const Button = () => <button style={{color: 'red'}}>Click me!</button>
const StyledButton = withStyles(Button)
```
- 여러 고차 컴포넌트를 조합하여 사용하게 된다면 어떤 고차 컴포넌트가 어떤 prop을 제공하는지 파악하기 어려울 수 있다.
- 이렇게 되면 디버깅과 애플리케이션 확장에 어려움이 생길 수 있다.

# 렌더링 Props 패턴
- 렌더링 Props 패턴은 컴포넌트를 재사용하는 또 다른 방법이다.
- 렌더링 prop은 JSX 요소를 반환하는 함수 값을 가지는 컴포넌트의 prop이다.
- 컴포넌트 자체는 렌더링 prop 외에는 아무것도 렌더링하지 않는다.
```tsx
const Title = (props) => {
    <>
        {props.renderFirstComponent()}
        {props.renderSecondComponent()}
        {props.renderThirdComponent()}
    </>
};

render(
    <div className="App">
        <Title
            renderFirstComponent={() => <h1>First render prop!</h1>}
            renderSecondComponent={() => <h2>Second render prop!</h2>}
            renderThirdComponent={() => <h3>Third render prop!</h3>}
        />
    </div>,
    document.getElementById("root")
);
```

# 리액트 Hooks 패턴
## Hooks
- 클래스 컴포넌트가 항상 최선의 선택은 아니다.
- 리액트 Hooks를 사용하면 다음과 같은 구현이 가능하다.
### 함수형 컴포넌트에 상태 추가하기
### componentDidMount, componentWillUnmount 같은 라이프사이클 메서드를 사용하지 않고도 컴포넌트의 라이프사이클 관리하기
### 여러 컴포넌트 간에 동일한 상태 관련 로직 재사용하기

## Hook의 장단점
- Hook을 사용하면 다음과 같은 이점을 얻을 수 있다.
### 더 적은 코드 라인 수
- Hook을 사용하면 코드를 라이프사이클별로 나누지 않고, 관심사 및 기능별로 그룹화 할 수 있다.
### 복잡한 컴포넌트의 단순화
- 자바스크립트의 클래스는 관리가 어렵고, 핫 리로딩과 함께 사용하기 힘들며, 코드 경량화가 어려울 수 있다.
- Hook은 이러한 문제를 해결하고 함수형 프로그래밍을 쉽게 구현할 수 있다.
### 상태 관련 로직 재사용
- 자바스크립트의 클래스는 여러 단계에 걸친 상속 때문에 전체적인 복잡성을 높이고 에러 발생 가능성을 증가시킬 수 있다.
- 그러나 Hook을 사용하면 클래스를 작성하지 않고도 상태와 함께 리액트의 다른 기능을 사용할 수 있다.
### UI에서 분리된 로직 공유
- Hook이 도입되기 전에는 리액트에서 UI와 무관한 로직을 추출하고 공유할 방법이 없었다.
- 이로 인해 고차 컴포넌트 패턴이나 렌더링 Props와 같은 복잡한 방법을 동원해야만 했다.
- 하지만 Hook의 등장으로 상태 관련 로직을 단순한 자바스크립트 함수로 추출할 수 있게 해주며 문제를 해결할 수 있었다.

# 동적 가져오기
- 리액트에서 제공하는 Suspense 컴포넌트는 동적으로 로드되어야 할 컴포넌트를 감싸는데, 이는 모듈의 가져오기를 일시적으로 중단시킴으로써 App 컴포넌트가 더 빠르게 내용을 렌더링할 수 있게 해준다.

## 윈도잉/가상화의 작동 방식
- 리스트 가상화는 현재 화면에 보이는 항목만 렌더링하여 성능을 최적화하는 기술이다.
- react-virtualized에서 윈도잉은 다음과 같은 방식으로 작동한다.
```md
- 상대적인 위치를 가진 작은 컨테이너 DOM 요소를 윈도우로 사용한다.
- 스크롤을 위한 큰 DOM 요소를 가진다.
- 컨테이너 내부에 자식 요소를 절대 위치로 배치하고, top, left, width, height 등의 스타일을 설정한다.
- 한 번에 수천 개의 목록 요소를 렌더링하여 초기 렌더링 속도 저하 또는 스크롤 성능 저하를 유발하는 대신, 가상화는 사용자에게 보이는 항목만 렌더링하는 데 집중한다.
```
