# 패턴 선택하기
- 어느 프로젝트에나 어울리는 최고의 패턴은 존재하지 않는다.
- 대신 패턴의 실질적인 구현에 도움이 되는지를 고려해야 한다.

# 생성자 패턴
- 생성자는 객체가 새로 만들어진 뒤 초기화하는 데에 사용되는 특별한 메서드다.
```md
객체 생성자는 특정 유형의 객체를 생성할 때 사용되었다.
객체가 처음 생성되었을 때 인수로 받아온 값을 객체 멤버의 변수와 메서드에 할당하는 동시에 사용할 준비를 마친다.
```

# 객체 생성
```ts
// ECMAScript 3 호환 방식
// 1. 도트 Dot(.) 문법
// 속성 할당하기
newObject.someKey = "Hello World";

// 속성 가져오기
var key = newObject.someKey;

// 2. 대괄호 문법
// 속성 할당하기
newObject["someKey"] = "Hello World";

// 속성 가져오기
var key = newObject["someKey"];


// ECMAScript 5 만 호환되는 방식
// 3. Object.defineProperty
// 속성 할당하기
Object.defineProperty( newObject, "someKey", {
    value: "for more control of the property's behavior".
    writable: true,
    enumerable: true,
    configurable: true
});

// 4. 앞선 방법이 조금 복잡하다면 이렇게도 가능
var defineProp = function ( obj, key, value ){
    config.value = value;
    Object.defineProperty( obj, key, config );
};

// 사용하는 법
// 빈 객체 "person" 생성
var person = Object.create( null );

// 속성 할당
defineProp( person, "car", "Delorean" );
defineProp( person, "dateOfBirth", "1981" );
defineProp( person, "hasBeard", false );

// 5. Object.defineProperties
// 속성 할당
Object.defineProperties( newObject, {

    "someKey": {
        value: "Hello World",
        writable: true
    },

    "anotherKey": {
        value: "Foo bar",
        writable: false
    }

});
```

- 위에까지는 근데 var를 사용하고 있어서 웬만하면 안 사용할 것 같고, 밑의 ES2015+ 방식인 const 선언 방식으로 사용하는게 좋을 듯
```ts
// ES2015+ 문법이 사용되었습니다(const)
// 사용법:

// "person" 객체를 상속하는 driver 객체를 생성합니다.
const driver = Object.create(person);

// 속성을 할당합니다.
defineProp(driver, 'topSpeed', '100mph');

// 상속받은 속성 값을 가져옵니다.
console.log(driver.dateOfBirth);

// 할당한 속성 값을 가져옵니다.
console.log(driver.topSpeed);
```

# 생성자의 기본 특징
- 클래스는 새 객체를 초기화하는 constructor()라는 이름의 메서들르 가지고 있어야 한다.
- 또한 new 키워드는 생성자를 호출할 수 있으며, 생성자 내부에서 사용된 this 키워드는 새로 생성된 해당 객체를 가리킨다.
```ts
class Car {
    constructor(model, year, miles) {
        this.model = model;
        this.year = year;
        this.miles = miles;
    }

    toString() {
        return `${this.model} has done ${this.miles} miles`;
    }
}

// 사용법

// 새로운 Car 인스턴스 생성
let civic = new Car('Honda Civic', 2009, 20000);
let mondeo = new Car('Ford Mondeo', 2010, 50000);

// 브라우저 콘솔을 열어서 결과 확인
console.log(civic.toString());
console.log(mondeo.toString());

```

# 프로토타입을 가진 생성자
- 자바스크립트의 프로토타입 객체는 함수나 클래스 등 특정 객체의 모든 인스턴스 내에 공통 메서드를 쉽게 정의할 수 있게 한다.
- 생성자를 통해 객체를 생성하면 생성자의 프로토타입 객체에 속한 속성을 새 객체에서도 활용할 수 있다.
- 이러한 방식으로 동일한 프로토타입 객체를 사용하는 여러 개의 Car 객체를 만들 수 있다.
```ts
class Car {
    constructor(model, year, miles) {
        this.model = model;
        this.year = year;
        this.miles = miles;
    }
}

// 프로토타입 객체의 재정의를 피하기 위해 Object.prototype 대신
// Object.prototye.newMethod 형태를 사용하고 있음을 유의하자.
// 기존에 이미 정의된 프로토타입 객체를 유지하기 위해서이다.

Car.prototype.toString = function() {
    return `${this.model} has done ${this.miles} miles`;
};

// 사용법:
let civic = new Car('Honda Civic', 2009, 20000);
let mondeo = new Car('Ford Mondeo', 2010, 50000);

console.log(civic.toString());
console.log(mondeo.toString());
```
- 근데 내 생각에는 Class의 바디 안에 공용 메서드를 두는게 응집력 측면에 있어서 더 좋을 것 같다. (뭐, 무조건 이게 정답은 또 아닐 수 있음...)

# 모듈 패턴
- 모듈은 애플리케이션 아키텍처의 핵심 구성 요소이며 프로젝트를 구성하는 코드 단위를 체계적으로 분리 및 관리하는 데 효과적으로 활용된다.
- 초기 자바스크립트에서는 다음과 같은 다양한 방법으로 모듈을 구현했다.
### 객체 리터럴 표기법
### 모듈 패턴
### AMD 모듈
### CommonJS 모듈

## 객체 리터럴
- 객체 리터럴 표기법은 객체는 중괄호 안에서 키와 값을 쉽표로 구분하여 객체를 정의하는 방법이다.
- 객체 내부의 키는 문자열 또는 식별자를 사용하며 콜론으로 끝마친다.
```ts
const myObjectLiteral = {
    variableKey: variableValue,
    functionKey() {
        // ...
    }
};
```
- 객체 리터럴은 선언 시 new 연산자를 필요로 하지 않으며, ```{```를 통해 객체 블록의 시작을 명시한다.
- 다음은 객체 리터럴 표기법을 사용하여 모듈을 정의한 예제이다.
```ts
const myModule = {
    myProperty: 'someValue',
    // 객체 리터럴은 속성으로 값과 메서드를 모두 가질 수 있다.
    // 예를 들어 객체 안에 객체를 다시 생성할 수도 있다.
    myConfig: {
        useCaching: true,
        language: 'en',
    },
    // 간단한 메서드 예시
    saySomething() {
        console.log('Where is Paul Irish debugging today?');
    },
    // 현재 객체의 속성 값을 사용하는 메서드
    reportMyConfig() {
        console.log(
            `Caching is: ${this.myConfig.useCaching ? 'enabled' : 'disabled'}`
        );
    },
    // 현재 객체의 속성 값을 덮어씌우는(override) 메서드
    updateMyConfig(newConfig) {
        if (typeof newConfig === 'object') {
            this.myConfig = newConfig;
            console.log(this.myConfig.language);
        }
    },
};

// 출력: What is Paul Irish debugging today?
myModule.saySomething();

// 출력: Caching is: enabled
myModule.reportMyConfig();

// 출력: fr
myModule.updateMyConfig({
    language: 'fr',
    useCaching: false,
});

// 출력: Caching is: disabled
myModule.reportMyConfig();
```
- 객체 리터럴을 사용하면 코드를 캡슐화하여 깔끔하고 체계적으로 정리할 수 있다.

## 모듈 패턴
- 모듈 패턴은 전통적인 소프트웨어 엔지니어링 분야에서 클래스의 캡슐화를 위해 처음 고안되었다.
### 비공개
- 모듈 패턴은 클로저를 활용해 '비공개' 상태와 구성을 캡슐화한다.
- 이는 공개 및 비공개 메서드와 변수를 묶어 전역 스코프로의 유출을 방지하고 다른 개발자의 인터페이스와의 충돌을 예방한다.
- 모듈 패턴을 사용한다면 공개 API만을 노출하고 나머지는 클로저 내부에 비공개로 유지할 수 있다.
- 이를 통해 다른 애플리케이션이 사용해야 하는 부분만 노출하고, 핵심 작업은 보호하는 깔끔하고 체계적인 구조를 구축할 수 있다.
- 또한 모듈 패턴은 직시 실행 함수를 사용해 객체를 반환한다.
### 예제
- 선언
```ts
let counter = 0;

const testModule = {
    incrementCounter() {
        return counter++;
    },
    resetCounter() {
        console.log(`counter value prior to reset: ${counter}`);
        counter = 0;
    },
};

export default testModule;
```
- 사용
```ts
// 모듈을 가져올 경로 설정
import testModule from './testModule';

// 카운터 증가
testModule.incrementCounter();

// 카운터 값을 확인하고 리셋
// 출력: counter value prior to reset: 1
testModule.resetCounter();
```
- 여기서 다른 파일ㄷ들은 incrementCounter()나 resetCounter()를 직접 읽지 못한다.
- counter 변수는 전역 스코프로부터 완전히 보호되어 비공개 변수로서 작동한다.
- 모듈의 클로저 내부로 스코프가 제한되어 오직 incrementCounter()나 resetCounter()만이 접근할 수 있다.
- 모듈 패턴을 사용하기 전에 간단한 템플릿을 만들어두면 도움이 된다.
- 다음은 네임스페이스, 공개 및 비공개 변수를 다루는 템플릿의 예제이다.
```ts
// 비공개 카운터 변수
let myPrivateVar = 0;

// 인자를 출력하는 비공개 함수
const myPrivateMethod = foo => {
    console.log(foo);
};

const myNamespace = {
    // 공개 변수
    myPublicVar: 'foo',

    // 비공개 변수와 함수를 다루는 공개 함수
    myPublicFunction(bar) {
        // 비공개 카운터 증가
        myPrivateVar++;

        // 비공개 함수 호출
        myPrivateMethod(bar);
    },
};

export default myNamespace;
```
- 다음은 다른 예제로 장바구니를 구현해보자
- 모듈 자체는 basketModule이라는 전역 변수 안에 독립적으로 존재하고 있다.
- basket 배열은 모듈 내부에서 비공개로 유지되기에 다른 파일에서 읽어 들일 수 없다.
- 즉, 모듈의 클로저 내부에서 보호되고 있기에 addItem()이나 getItem()처럼 같은 스코프 안에 존재하는 메서드만이 접근할 수 있다.

```ts
// 비공개 변수 및 함수
const basket = [];

const doSomethingPrivate = () => {
    //...
};

const doSomethingElsePrivate = () => {
    //...
}

// 다른 파일에 공개할 객체 생성
const basketModule = {
    // Add items to our basket
    addItem(values) {
        basket.push(values);
    },

    // basket의 길이 가져오기
    getItemCount() {
        return basket.length;
    },

    // 비공개 함수를 공개 함수로 감싸 다른 이름으로 사용하기
    doSomething() {
        doSomethingPrivate();
    },

    // basket에 담긴 아이템의 합계 가져오기
    // reduce() 메서드를 사용하면 배열의 아이템을 하나의 값으로 줄일 수 있다.
    getTotal() {
        return basket.reduce((currentSum, item) => item.price + currentSum, 0);
    },
};

export default basketModule;
```
### 비공개 자유성
- 모듈 내부에서만 사용 가능한 비공개 함수를 자유롭게 만들 수 있다.
- 다른 파일에서 접근할 수 없기에 완전한 비공개를 실현할 수 있다.

### 디버깅 용이성
- 대개 함수는 선언되고 이름이 정해지므로, 어떤 함수가 예외를 발생시켰는지 알아내려고 할 때 디버거에서 콜 스택을 찾기 쉬워진다.

## 모듈 패턴의 변형
- 시간이 지나면서 각자의 입맛에 맞는 모듈 패턴의 변형들이 등장하기 시작했다.
### 믹스인 가져오기 변형
- 이 변형된 패턴은 유틸 함수나 외부 라이브러리 같은 전역 스코프에 있는 요소를 모듈 내부의 고차 함수에 인자로 전달 할 수 있게 한다.
- 이를 통해 전역 스코프 요소를 가져와 맘대로 이름을 지정할 수 있다.
```ts
// utils.js
export const min = (arr) => Math.min(...arr);

// privateMethods.js
import {min} from "./utils";

export const privateMethod = () => {
    console.log(min([10, 5, 100, 2, 1000]));
};

// myModule.js
import { privateMethod } from "./privateMethods";

const myModule = () => ({
    publicMethod() {
        privateMethod();
    },
});

export default myModule;

// main.jsx
import myModule from "./myModule";

const moduleInstance = myModule();
moduleInstance.publicMethod();
```
### 내보내기 변형
- 다음 변형은 따로 이름을 지정해주지 않고 전역 스코프로 변수를 내보낸다.
```ts
// module.js
const privateVariable = "Hello World";

const privateMethod = () => {
    // ...
}

const module = {
    publicProperty: "Foobar",
    publicMethod: () => {
        console.log(privateVariable);
    },
};

export default module;
```
### 장점
- 자바스크립트의 관점에서 볼 때 모듈 패턴은 캡슐화 개념보다 객체 지향 프로그래밍 지식을 가진 초보 개발자가 이해하기 쉽다.
- 바깥으로 노출하지 않은 값은 모듈 내부에 비공개로 유지가 되므로 불필요한 전역 스코프 오염을 방지할 수 있다.
- 모듈을 사용하는 개발자는 어쩌다 실수로 같은 이름을 가진 값을 덮어씌울 걱정을 덜 수 있다.
- 모듈 패턴은 공개되면 안 되는 코드를 캡슐화할 수 있다.
- 덕분에 여러 의존성을 동시에 사용할 수 있고 이름의 충돌도 피할 수 있다.

### 단점
- 공개와 비공개 멤버를 서로 다르게 접근해야 한다.
- 공개 여부를 바꾸고 싶으면 값이 위치한 파일로 가서 각각 바꾸어주어야 한다.
- 자동화 단위 테스트에서 비공개 멤버는 제외된다는 것과 핫픽스가 필요한 오류를 고칠 때 복잡도를 높인다.

## WeakMap을 사용하는 최신 모듈 패턴
- ES6에서 도입된 WeakMap 객체는 약한 참조를 가진 키-값의 쌍으로 이루어진 집합체이다.
- 키는 객체여야만 하나, 값으로는 뭐든지 넣을 수 있다.
- WeakMap 객체는 기본적으로 키가 약하게 유지되는 맵이기 때문에 참조되지 않는 키는 GC의 대상이 된다.

## 최신 라이브러리와 모듈
- 리액트 같은 자바스크립트 라이브러리를 만들 때 모듈 패턴을 사용할 수도 있다.
```tsx
import React from "react";
import Button from "@material-ui/core/Button";

const style = {
    root: {
        borderRadius: 3,
        border: 0,
        color: "white",
        margin: "0 200px"
    },
    primary: {
        background: "linear-gradient(45deg, #FE6B8B 30%, #FF8E53 90%)"
    },
    secondary: {
        background: "linear-gradient(45deg, #2196f3 30%, #21cbf3 90%)"
    }
};

export default function CustomButton(props) {
    return (
        <Button {...props} style={{ ...style.root, ...style[props.color] }}>
            {props.children}
        </Button>
    )
}
```

# 싱글톤 패턴
- 싱글톤 패턴은 클래스의 인스턴스가 오직 하나만 존재하도록 제한하는 패턴이다.
- 싱글톤 패턴은 정적 클래스나 객체와는 다르게 초기화를 지연시킬 수 있다. 왜냐하면 초기화 시점에 필요한 특정 정보가 유효하지 않은 수도 있기 때문이다.
```ts
// 싱글톤에 대한 참조를 가지는 인스턴스
let instance;

// 비공개 메서드와 변수
const privateMethod = () => {
    console.log('I am private');
};
const privateVariable ='Im also private';
const randomNumber = Math.random();

// 싱글톤
class MySingleton {
    // 싱글톤 인스턴스가 이미 존재한다면 참조를 반환하고
    // 존재하지 않으면 생성한다.
    constructor() {
        if (!instance) {
            // 공개된 속성
            this.publicProperty = 'I am also public';
            instance = this;
        }

        return instance;
    }

    // 공개 메서드
    publicMethod() {
        console.log('The public can see me!');
    }

    getRandomNumber() {
        return randomNumber;
    }
}

// [ES2015+] 이름 없이 기본 값으로 내보내기
export default MySingleton;

// 싱글톤에 대한 참조를 가지는 인스턴스
let instance;

// 싱글톤
class MyBadSingleton {
    // 항상 새로운 싱글톤 인스턴스를 생성
    constructor() {
        this.randomNumber = Math.random();
        instance = this;

        return instance;
    }

    getRandomNumber() {
        return this.randomNumber;
    }
}

export default MyBadSingleton;

// 사용법
import MySingleton from './MySingleton';
import MyBadSingleton from './MyBadSingleton';

const singleA = new MySingleton();
const singleB = new MySingleton();
console.log(singleA.getRandomNumber() === singleB.getRandomNumber());
// true 출력

const badSingleA = new MyBadSingleton();
const badSingleB = new MyBadSingleton();
console.log(badSingleA.getRandomNumber() !== badSingleB.getRandomNumber());
// true 출력
```
- 싱글톤의 특징은 인스턴스에 대한 전역 접근을 허용한다는 것이다.
- GoF의 책 ```GoF의 디자인 패턴```에서는 싱글톤 패턴의 적합성을 다음과 같이 말한다.
- 싱글톤은 유용하지만, 자바스크립트에서 싱글톤이 필요하다는 것은 설계를 다시 생각해 봐야 한다는 신호일 수도 있다.
- 객체를 생성하기 위해 클래스를 정의해야 하는 C++나 자바와 달리, 자바스크립트는 객체를 직접적으로 생성할 수 있다.
- 따라서 싱글톤 클래스를 만드는 대신에 직접 객체 하나를 생성할 수도 있다는 뜻이다.
- 자바스크립트에서 싱글톤 클래스를 사용하는 것에는 다음과 같은 단점들이 있다.
### 싱글톤임을 파악하는 것이 힘들다
- 큰 모듈을 가져오는 경우, 어떤 클래스가 싱글톤 클래스인지 알아내기 어렵다.
- 그러므로 싱글톤 클래스를 일반 클래스로 착각하여 여러 객체를 인스턴스화하거나 부적절한 방법으로 수정할 수도 있다.
### 테스트하기 힘들다
- 싱글톤은 숨겨진 의존성, 여러 인스턴스 생성의 어려움, 의존성 대체의 어려움을 등 다양한 문제로 테스트하기에 생각보다 더 어려울 수 있다.
### 신중한 조정이 필요하다
- 싱글톤의 일상적인 사용 사례로는 전역 범위에 걸쳐 필요한 데이터를 저장하는 것이 있다.
- 예를 들어 한 번 설정되고 난 후에 여러 컴포넌트에서 사용할 수 있는 사용자 인증 정보나 쿠키 등이 있다.
- 따라서 데이터가 유효하게 된 뒤에 사용할 수 있도록 올바른 실행 순서를 구현하는 일이 필수지만, 애플리케이션의 크기와 복잡성이 커짐에 따라 어려워질 수 있다.

## 리액트의 상태 관리
- 리액트를 통해 웹 개발을 한다면 싱글톤 대신 Context API나 리덕스 같은 전역 상태 관리 도구를 이용하여 개발할 수도 있다.
- 싱글톤과는 달리, 이러한 전역 상태 관리 도구는 변경 불가능한 읽기 전용 상태를 제공한다.
- 이러한 도구를 사용한다고 해서 전역 상태가 가지는 여러 단점을 손쉽게 처리할 수는 없지만, 적어도 컴포넌트가 전역 상태를 직접 변경할 수 없게 만들어 전역 상태가 의도한 대로 변경될 수 있도록 도와준다.

# 프로토타입 패턴
- GoF는 프로토타입 패턴을 이미 존재하는 객체를 복제해 만든 템플릿을 기반으로 새 객체를 생성하는 패턴이라고 정의했다.
- 프로토타입 패턴은 프로토타입의 상속을 기반으로 한다. 이 패턴에서는 프로토타입 역할을 할 전용 객체를 생성하게 된다.
- 이렇게 만들어진 prototype 객체는 생성자를 통해 만들어진 객체의 설계도가 된다.
- 예를 들어 생성자 함수의 프로토타입이 name 속성을 가지고 있다면, 해당 생성자 함수를 사용해 만들어진 객체들은 모두 name 속성을 가지게 된다.
- 자바스크립트 생태계 바깥에서 프로토타입의 정의를 찾아 올라가면 클래스에 대한 언급을 어쩌면 찾을 수도 있다.
- 그러나 실제로는 프로토타입 상속과 클래스는 별개로 사용된다.
- 프로토타입 상속은 클래스처럼 따로 정의되는 것이 아니라, 이미 존재하는 다른 객체를 복제하여 새로운 객체를 만들어낸다.
- 프로토타입 패턴의 장점은 다른 언어의 기능을 따라 하지 않고, 자바스크립트만이 가진 고유의 방식으로 작업할 수 있다는 것이다.
- 프로토타입 태턴은 상속을 구현하는 쉬운 방법일 뿐만 아니라 성능에서의 이점도 챙길 수 있다.
- 객체 내에 함수를 정의할 때 복사본이 아닌 참조로 생성되어 모든 자식 객체가 동일한 함수를 가리키게 할 수 있기 때문이다.
- ECMAScript 5 표준에 따라 프로토타입의 상속은 ```Object.create```를 필요로 한다.
- 다시 말해 ```Object.create```는 프로토타입 객체를 생성하고 특정 속성을 추가할 수도 있다.
```ts
const myCar = {
    name: 'Ford Escort',

    drive() {
        console.log("Weeee. I'm driving!");
    }

    panic() {
        console.log("Wait. How do you stop this thing?");
    },
};

// 새로운 car를 인스턴스화하기 위해 Object.create를 사용
const yourCar = Object.create(myCar);

// 프로토타입이 제대로 들어왔음을 알 수 있다.
console.log(yourCar.name);
```
- Object.create는 다른 객체로부터 직접 상속할 수 있게 해주는 차등 상속과 같은 고급 개념을 쉽게 구현할 수 있게 해준다.
- Object.create는 두 번째 인자를 사용하여 객체의 속성을 초기화할 수 있게 해준다.
```ts
const vehicle = {
    getModel() {
        console.log(`The model of this vehicle is...${this.model}`);
    },
};

const car = Object.create(vehicle, {
    id: {
        value: MY_GLOBAL.nextId(),
        // writable: false, configurable:false가 기본적으로 들어간다.
        enumerable: true,
    },

    model: {
        value: 'Ford',
        enumerable: true,
    },
});
```
- 이 예제는 앞서 봤던 Object.defineProperties와 Object.defineProperty 메서드와 비슷한 방식으로 Object.create의 두 번째 인자를 사용해 객체의 속성을 초기화하는 방법을 보여준다.
- Object.create를 사용하지 않고 프로토타입 패턴을 구현하고 싶다면 다음과 같이 시도해 볼 수 있다.
```ts
class VehiclePrototype {
    constructor(model) {
        this.model = model;
    }

    getModel() {
        console.log(`The model of this vehicle is... ${this.model}`);
    }

    clone() {}
}

class Vehicle extends VehiclePrototype {
    constructor(model) {
        super(model);
    }

    clone() {
        return new Vehicle(this.model);
    }
}

const car = new Vehicle('Ford Escort');
const car2 = car.clone();
car2.getModel();
```

# 팩토리 패턴
- 팩토리 패턴은 객체를 생성하는 생성 패턴의 하나이다.
- 다른 패턴과 달리 생성자를 필요로하지 않지만, 필요한 타입의 팩토리 객체를 생성하는 다른 방법을 제공한다.
- 팩토리 패턴은 동적인 요소나 애플리케이션 구조에 깊게 의지하는 등의 상황처럼 객체 생성 과정이 복잡할 때 특히 유용하다.
```ts
// 자동차를 정의하는 클래스
class Car {
    constructor({ doors = 4, state = 'brand new', color = 'silver' } = {}) {
        this.doors = doors;
        this.state = state;
        this.color = color;
    }
}

// 트럭을 정의하는 클래스
class Truck {
    constructor({ state = 'used', wheelSize = 'large', color = 'blue' } = {}) {
        this.state = state;
        this.wheelSize = wheelSize;
        this.color = color;
    }
}

// FactoryExample.js
// 차량 팩토리를 정의
class VehicleFactory {
    constructor() {
        this.vehicleClass = Car;
    }

    // 새 차량 인스턴스를 생성하는 팩토리 함수
    createVehicle(options) {
        const { vehicleType, ...rest } = options;

        switch (vehicleType) {
            case 'car':
                this.vehicleClass = Car;
                break;
            case 'truck':
                this.vehicleClass = Truck;
                break;
                // 해당되지 않으면 VehicleFactory.prototype.vehicleClass에 Car를 할당
        }

        return new this.vehicleClass(rest);
    }
}

// 자동차를 만드는 팩토리의 인스턴스 생성
const carFactory = new VehicleFactory();
const car = carFactory.createVehicle({
    vehicleType: 'car',
    color: 'yellow',
    doors: 6,
});

// 자동차가 vehicleClasss/prototype Car로 생성되었는지 확인
// 출력: true
console.log(car instanceof Car);
// color: "yellow", doors: 6, state: "brand new" 인 자동차 객체 출력
console.log(car);
```
- 각 차량과 관련된 속성을 설정하는 생성자로 자동차와 트럭 클래스가 정의되었다.
- 그리고 VehicleFactory는 전달된 vehicleType에 따라 새 Car 또는 Truck 차량 객체를 생성할 수 있다.
- VehicleFactory 클래스를 통해 트럭을 만드는 방법은 크게 2가지가 있을 수 있다.
### 1번째 방법
```ts
const movingTruck = carFactory.createVehicle({
    vehicleType: 'truck',
    state: 'like new',
    color: 'red',
    wheelSize: 'small',
});

// 트럭이 vehicleClass/prototype Truck으로 생성되었는지 확인
// 출력: true
console.log(movingTruck instanceof Truck);

// color: "red", state: "like new", wheelSize: "small" 인 자동차 객체 출력
console.log(movingTruck);
```
### 2번째 방법
```ts
class TruckFactory extends VehicleFactory {
    constructor() {
        super();
        this.vehicleClass = Truck;
    }
}

const truckFactory = new TruckFactory();
cont myBigTruck = truckFactory.createVehicle({
    state: 'omg... so bad.',
    color: 'pink',
    wheelSize: 'so big',
});

// myBigTruck이 prototype Truck으로 생성되었는지 확인
// 출력: true
console.log(myBigTruck instanceof Truck);

// color: "pink", wheelSize: "so big",
// state: "omg. so bad"를 가진 트럭 객체 출력
console.log(myBigTruck);
```
## 팩토리 패턴을 사용하면 좋은 상황
- 객체나 컴포넌트의 생성 과정이 높은 복잡성을 가지고 있을 때
- 상황에 맞춰 다양한 객체 인스턴스를 편리하게 생성할 수 있는 방법이 필요할 때
- 같은 속성을 공유하는 여러 개의 작은 객체 또는 컴포넌트를 다뤄야 할 때
- 덕 타이핑과 같은 API 규칙만 충족하면 되는 다른 객체의 인스턴스와 함께 객체를 구성할 때, 또한 디커플링에도 유용하다.
## 팩토리 패턴을 사용하면 안 되는 상황
- 팩토리 패턴은 객체 생성 과정을 인터페이스 뒤에 추상화하기 때문에 객체 생성 과정이 복잡할 경우 단위 테스트의 복잡성 또한 증가시킬 수 있다.

## 추상 팩토리 패턴
- 추상 팩토리는 같은 목표를 가진 각각의 픽토리들을 하나의 그룹으로 캡슐화하는 패턴이다.
- 또한 객체가 어떻게 생성되는지에 대한 세부사항을 알 필요 없이 객체를 사용할 수 있게 한다.
- 객체의 생성 과정에 영향을 받지 않아야 하거나 여러 타입의 객체로 작업해야 하는 경우에 추상 팩토리를 사용하면 좋다.

# 퍼사드 패턴
- 퍼사드란 실제 모습을 숨기고 꾸며낸 겉모습만을 세상에 드러내는 것을 뜻한다.
- 퍼사드 패턴은 심층적인 복잡성을 숨기고, 사용하기 편리한 높은 수준의 인터페이스를 제공하는 패턴이다.
- 퍼사드는 jQuery 같은 자바스크립트 라이브러리에서 흔히 볼 수 있는 구조 패턴이다.
- 예를 들면 jQuery의 $(el).css나 $(el).animate() 같은 메서드가 있을 것 같다.
- 퍼사드 패턴은 클래스의 인터페이스를 단순화하고 코드의 구현 부분과 사용 부분을 분리한다.
- 이를 통해 하위 시스템에 직접 접근하기보단 간접적으로 상호작용하여 에러를 줄일 수도 있다.
- 퍼사드의 장점은 사용하기 쉽다는 점과 패턴 구현에 필요한 코드의 양이 적다는 점이다.
```ts
const addMyEvent = (el, ev, fn) => {
    if (el.addEventListener) {
        el.addEventListener(ev, fn, false);
    } else if (el.attachEvent) {
        el.attachEvent(`on${ev}`, fn);
    } else {
        el[`on${ev}`] = fn;
    }
}
```
- 퍼사드 패턴을 단독으로 사용해야만 하는 것은 아니다.
- 모듈 패턴 같은 다른 패턴과도 어울릴 수 있다.
- 다음 예시는 퍼사드 패턴이 모듈 패턴의 메서드에 접근하는 간단한 API를 제공한다.
```ts
// privateMethods.js
const _private = {
    i: 5,
    get() {
        console.log(`current value: ${this.i}`);
    },
    set(val) {
        this.i = val;
    },
    run() {
        console.log('running');
    },
    jump() {
        console.log('jumping');
    },
};

export default _private;

// module.js
import _private from './privateMethods.js';

const module = {
    facade({ val, run }) {
        _private.set(val);
        _private.get();
        if (run) {
            _private.run();
        }
    },
};

export default module;

// index.js
import module from './module.js';

// 출력: "current value: 10" and "running"
moduel.facade({
    run: true,
    val: 10,
});
```
- 위의 예제에서 module.facade()는 모듈 내부에서 비밀스런 동작을 실행하지만 사용자는 내부에서 무슨 일이 벌어지는지 몰라도 된다.

# 서브클래싱
- 부모 클래스를 확장하는 자식 클래스를 서브클래스라고 한다.
- 서브클래싱이란 부모 클래스 객체에서 속성을 상속받아 새로운 객체를 만드는 것을 뜻한다.
- 서브클래스는 부모 클래스에서 먼저 정의된 메서드를 오버라이드 하는 것도 가능하다.
- 서브클래스의 메서드는 오버라이드된 부모 클래스의 메서드를 호출할 수도 있는데, 이를 메서드 체이닝이라고 부른다.
- 마찬가지로 부모 클래스의 생성자를 호출할 수도 있는데, 이를 생성자 체이닝이라고 부른다.
```ts
class Person{
    constructor(firstName, lastName) {
        this.firstName = firstName;
        this.lastName = lastName;
        this.gender = "male";
    }
}

// Person의 새 인스턴스는 이처럼 쉽게 생성된다.
const clark = new Person( 'Clark', 'Kent' );
```
- 다음으로 Person 클래스의 서브클래스가 되는 새 클래스를 만들어보자.
- 부모 클래스인 Person의 속성을 상속하면서 Person과 Superhero를 구분할 수 있는 별개의 속성을 추가하고 싶다고 하자.
- 슈퍼히어로는 일반 사람과 이름, 성별 등 많은 특징을 공유하기 때문에 서브클래싱을 아주 잘 설명할 수 있다.
```ts
class Superhero extend Person {
    constructor(firstName, lastName, powers) {
        // 부모 클래스의 생성자를 호출한다.
        super(firstName, lastName);
        this.powers = powers;
    }
}

// Superhero 인스턴스를 만든다.

const SuperMan = new Superhero('Clark', 'Kent', ['flight', 'heat-vision']);
console.log(SuperMan);

// power를 가진 Person을 출력한다.
```
- Superhero 클래스의 생성자는 Person 클래스를 확장해 인스턴스를 생성한다.
- 그리하여 Superhero 객체는 Person 클래스의 속성을 가지고 있다.
- 따라서 Person 클래스에서 기본 값을 설정해 두었더라도 Superhero 클래스에서 상속받은 값을 오버라이드하여 새로 할당할 수 있다.

# 데코레이터 패턴
- 데코레이터 패턴은 코드 재사용을 목표로 하는 구조 패턴이다.
- 데코레이터 패턴은 객체의 생성을 신경 쓰지 않는 대신 기능의 확장에 좀 더 초점을 둔다.
- 프로토타입의 상속에 의지하기보다는 하나의 베이스 클래스에 추가 기능을 제공하는 데코레이터 객체를 점진적으로 추가한다.
- 이는 서브클래싱 대신 베이스 객체에 속성이나 메서드를 추가하여 간소화하겠다는 아이디어이다.
- 자바스크립트는 데코레이터를 사용할 수 있는 베이스 클래스를 만들 수 있다.
```ts
// Vehicle 생성자
class Vehicle {
    constructor(vehicleType) {
        // 일부 합리적인 기본값
        this.vehicleType = vehicleType || 'car';
        this.model = 'default';
        this.license = '00000-000';
    }
}

// 기본 Vehicle에 대한 테스트 인스턴스
const testInstance = new Vehicle('car');
console.log(testInstance);

// 출력:
// vehicle: car, model: default, license: 00000-000

// 데코레이트될 새로운 차량 인스턴스를 생성합시다.
const truck = new Vehicle('truck');

// Vehicle에 추가하는 새로운 기능
truck.setModel = function(modelName) {
    this.model = modelName;
};

truck.setColor = function(color) {
    this.color = color;
};

// 값 설정자와 값 할당이 올바르게 작동하는지 테스트
truck.setModel('CAT');
truck.setColor('blue');

console.log(truck);

// 출력:
// vehicle: truck, model: CAT, color: blue

// "vehicle"이 변경되지 않았음으로 보여줍니다.
const secondInstance = new Vehicle('car');
console.log(secondInstance);

// 출력:
// vehicle: car, model: default, license: 00000-000
```
- 이 예제에서 truck은 Vehicle 클래스의 인스턴스이며, setColor와 setModel 메서드를 데코레이터로 추가했다.
```ts
// 데코레이터를 사용할 생성자
classs MacBook {
    constructor() {
        this.cost = 997;
        this.screenSize = 11.6;
    }
    getCost() {
        return this.cost;
    }
    getScreenSize() {
        return this.screenSize;
    }
}

// 데코레이터 1
class Memory extends MacBook {
    constructor(macBook) {
        super();
        this.macBook = macBook;
    }

    getCost() {
        return this.macBook.getCost() + 75;
    }
}

// 데코레이터 2
class Engraving extends MacBook {
    constructor(macBook) {
        super();
        this.macBook = macBook;
    }

    getCost() {
        return this.macBook.getCost() + 200;
    }
}

class Insurance extends MacBook {
    constructor(macBook) {
        super();
        this.macBook = macBook;
    }

    getCost() {
        return this.macBook.getCost() + 250;
    }
}

// 메인 객체 초기화
let mb = new MacBook();

// 데코레이터 초기화
mb = new Memory(mb);
mb = new Engraving(mb);
mb = new Insurance(mb);

// 출력: 1522
console.log(mb.getCost());

// 출력: 11.6
console.log(mb.getScreenSize());
```
- 이번 예제에서 맥북의 업그레이드에 필요한 추가 비용을 반환하기 위해 MacBook 부모 클래스 객체의 .getCost() 함수를 데코레이터로 오버라이드했다.
- 원본 MacBook 객체 생성자 메서드 중 오버라이드되지 않은 메서드(getScreenSize())는 그대로 유지되기에 데코레이터를 사용했다고 한다.

# 플라이웨이트 패턴
- 플라이웨이트 패턴은 반복되고 느리고 비효율적으로 데이터를 공유하는 코드를 최적화하는 전통적인 구조적 해결 방법이다.
- 연관된 객체끼리 데이터를 공유하게 하면서 애플리케이션의 메모리를 최소화하는 목적을 가지고 있다.
- 해당 패턴의 목표는 메모리 공간의 경량화이다.
- 실제로 플라이웨이트의 데이터 공유 방식은 여러 비슷한 객체나 데이터 구조에서 공통으로 사용되는 부분만을 하나의 외부 객체로 내보내는 것으로 이뤄진다.
- 각 객체에 데이터를 저장하기보다는 하나의 의존 외부 데이터에 모아서 저장할 수 있다.

## 사용법
- 플라이웨이트 패턴을 사용하는 두 가지 방법이 있다.
- 첫 번째는 데이터 레이어에서 메모리에 저장된 수많은 비슷한 객체 사이로 데이터를 공유하는 것이다.
- 두 번째는 DOM 레이어에도 플라이웨이트를 적용할 수 있다.
- 예를 들어 비슷한 동작을 하는 이벤트 핸들러를 모든 자식 요소에 등록하기보다는 부모 요소 같은 중앙 이벤트 관리자에게 맡기는 방법이 있다.

## 데이터 공유
- 플라이웨이트 패턴에는 두 가지 개념이 있다.
- 내재적 상태와 외재적 상태이다.
- 내재적 정보는 객체의 내부 메서드에 필요한 것이며, 없으면 절대로 동작하지 않는다.
- 외재적 정보는 반면에 제거되어 외부에 저장될 수 있다.
- 외재적 정보를 다룰 때에는 따로 관리자를 사용한다. 관리자는 플라이웨이트 객체와 내재적 상태를 보관하는 중앙 데이터베이스를 관리자로 사용하는 것이다.

## 플라이웨이트 패턴과 DOM 객체
- DOM은 하향식(이벤트 캡처링)과 상향식(이벤트 버블링) 두 가지 방식의 이벤트 감지를 지원한다.
- 플라이웨이트는 이벤트 버블링 과정을 추가 조정하는 데에 사용할 수 있다.

## 중앙 집중식 이벤트 핸들링
- 일반적으로 아코디언 컴포넌트, 메뉴 그리고 리스트 기반의 위젯 같은 것들을 설계할 때 부모 컨테이너 내부의 각 링크 요소에 '클릭' 이벤트를 바인딩하곤 한다.
- 하지만 여러 요소들에 하나하나 클릭 이벤트를 바인딩하는 대신, 최상위 컨테이너에 플라이웨이트를 부착하여 하위 요소로부터 전달되는 이벤트를 감지할 수 있다.
- 감지한 이벤트는 필요에 따라 간단하거나 복잡한 로직을 적용하여 원하는 기능을 구현하면 된다.

# 행위 패턴
- 행위 패턴은 객체 간의 의사소통을 돕는 패턴이다.
- 시스템 내 서로 다른 객체 간의 의사소통 방식을 개선하고 간소화하는 것을 목적으로 한다.
- 세가지 행위 패턴들이 있다.
### 관찰자 패턴
### 중재자 패턴
### 커맨드 패턴

# 관찰자 패턴
- 관찰자 패턴은 한 객체가 변경 될 때 다른 객체들에 변경되었음을 알릴 수 있게 해주는 패턴이다.
- 변경된 객체는 누가 자신을 구독하는지 알 필요 없이 알림을 보낼 수 있다.
- 한 객체를 관찰하는 여러 객체들이 존재하며, 주체의 상태가 변화하면 관찰자들에게 자동으로 알림을 보낸다.
### 주체
- 관찰자 리스트를 관리하고, 추가와 삭제를 가능하게 한다.
### 관찰자
- 주체의 상태 변화 알림을 감지하는 update 인터페이스를 제공한다.
### 구체적 주체 
- 상태 변화에 대한 알림을 모든 관찰자에게 전달하고, 구체적 관찰자의 상태를 저장한다.
### 구체적 관찰자
- 구체적 주체의 참조를 저장하고, 관찰자의 update 인터페이스를 구현하여 주체의 상태 변화와 관찰자의 상태 변화가 일치할 수 있도록 한다.

# 중재자 패턴
- 중재자 패턴은 하나의 객체가 이벤트 발생 시 다른 여러 객체들에게 알림을 보낼 수 있는 디자인 패턴이다.
- 이 패턴은 하나의 객체가 다른 객체에서 발생한 특정 유형의 이벤트에 대해 알림을 받을 수 있다는 점이다.
- 현실에서 유사한 사례를 찾는다면, 항공 교통 관제 시스템을 예시로 들 수 있다.
- 관제탑(중재자)은 항공기의 모든 통신이 관제탑을 거쳐 이루어지고, 항공기끼리 직접 통신하지 않게 하는 것으로 항공기의 이착륙을 관리한다.
- 다른 사례로는 DOM의 이벤트 버블링과 이벤트 위임을 둘 수 있다.
- 시스템의 모든 이벤트 등록이 이벤트가 일어날 개별 DOM 노드 대신 최상위 Document 객체를 대상으로 했을 경우 Document 객체는 사실상 중재자 역할을 하게 된다.